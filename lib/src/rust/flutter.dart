// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'error.dart';
import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'flutter.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `atomic_u32_deserialize`, `atomic_u32_serialize`, `invoke`, `new`, `notify`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `FlutterStatisticsCallback`, `SEND_TO_DART_LOGGER_STREAM_SINK`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `deref`, `do_logs`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `initialize`

Stream<String> createLogStream() =>
    RustLib.instance.api.crateFlutterCreateLogStream();

void rustSetUp() => RustLib.instance.api.crateFlutterRustSetUp();

(String, Uint8List) generateKeys() =>
    RustLib.instance.api.crateFlutterGenerateKeys();

String roomHash({required List<String> peers}) =>
    RustLib.instance.api.crateFlutterRoomHash(peers: peers);

bool validatePeerId({required String peerId}) =>
    RustLib.instance.api.crateFlutterValidatePeerId(peerId: peerId);

Future<bool> screenshareAvailable() =>
    RustLib.instance.api.crateFlutterScreenshareAvailable();

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Capabilities>>
abstract class Capabilities implements RustOpaqueInterface {
  static Future<Capabilities> default_() =>
      RustLib.instance.api.crateFlutterCapabilitiesDefault();

  List<String> devices();

  List<String> encoders();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChatMessage>>
abstract class ChatMessage implements RustOpaqueInterface {
  List<(String, Uint8List)> attachments();

  String get text;

  set text(String text);

  void clearAttachments();

  bool isSender({required String identity});

  String time();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CodecConfig>>
abstract class CodecConfig implements RustOpaqueInterface {
  static Future<CodecConfig> default_() =>
      RustLib.instance.api.crateFlutterCodecConfigDefault();

  factory CodecConfig(
          {required bool enabled,
          required bool vbr,
          required double residualBits}) =>
      RustLib.instance.api.crateFlutterCodecConfigNew(
          enabled: enabled, vbr: vbr, residualBits: residualBits);

  void setEnabled({required bool enabled});

  void setResidualBits({required double residualBits});

  void setVbr({required bool vbr});

  (bool, bool, double) toValues();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Contact>>
abstract class Contact implements RustOpaqueInterface {
  static Contact fromParts(
          {required String id,
          required String nickname,
          required String peerId}) =>
      RustLib.instance.api.crateFlutterContactFromParts(
          id: id, nickname: nickname, peerId: peerId);

  String id();

  bool idEq({required List<int> id});

  factory Contact({required String nickname, required String peerId}) =>
      RustLib.instance.api
          .crateFlutterContactNew(nickname: nickname, peerId: peerId);

  String nickname();

  String peerId();

  Contact pubClone();

  void setNickname({required String nickname});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartNotify>>
abstract class DartNotify implements RustOpaqueInterface {
  /// public notified function for dart
  Future<void> notified();

  /// notifies one waiter
  void notify();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlutterCallbacks>>
abstract class FlutterCallbacks implements RustOpaqueInterface {
  factory FlutterCallbacks(
          {required FutureOr<bool> Function((String, Uint8List?, DartNotify))
              acceptCall,
          required FutureOr<Contact?> Function(Uint8List) getContact,
          required FutureOr<void> Function(CallState) callState,
          required FutureOr<void> Function((String, SessionStatus))
              sessionStatus,
          required FutureOr<List<Contact>> Function(void) getContacts,
          required FutureOr<void> Function(Statistics) statistics,
          required FutureOr<void> Function(ChatMessage) messageReceived,
          required FutureOr<void> Function((bool, bool)) managerActive,
          required FutureOr<void> Function((DartNotify, bool))
              screenshareStarted}) =>
      RustLib.instance.api.crateFlutterFlutterCallbacksNew(
          acceptCall: acceptCall,
          getContact: getContact,
          callState: callState,
          sessionStatus: sessionStatus,
          getContacts: getContacts,
          statistics: statistics,
          messageReceived: messageReceived,
          managerActive: managerActive,
          screenshareStarted: screenshareStarted);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkConfig>>
abstract class NetworkConfig implements RustOpaqueInterface {
  static Future<NetworkConfig> default_() =>
      RustLib.instance.api.crateFlutterNetworkConfigDefault();

  Future<String> getRelayAddress();

  Future<String> getRelayId();

  factory NetworkConfig(
          {required String relayAddress, required String relayId}) =>
      RustLib.instance.api.crateFlutterNetworkConfigNew(
          relayAddress: relayAddress, relayId: relayId);

  Future<void> setRelayAddress({required String relayAddress});

  Future<void> setRelayId({required String relayId});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RecordingConfig>>
abstract class RecordingConfig implements RustOpaqueInterface {
  int bitrate();

  String device();

  String encoder();

  int framerate();

  int? height();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ScreenshareConfig>>
abstract class ScreenshareConfig implements RustOpaqueInterface {
  Future<Capabilities> capabilities();

  static Future<ScreenshareConfig> default_() =>
      RustLib.instance.api.crateFlutterScreenshareConfigDefault();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<ScreenshareConfig> newInstance({required String configStr}) =>
      RustLib.instance.api
          .crateFlutterScreenshareConfigNew(configStr: configStr);

  Future<RecordingConfig?> recordingConfig();

  @override
  String toString();

  Future<void> updateRecordingConfig(
      {required String encoder,
      required String device,
      required int bitrate,
      required int framerate,
      int? height});
}

@freezed
sealed class CallState with _$CallState {
  const CallState._();

  const factory CallState.connected() = CallState_Connected;
  const factory CallState.waiting() = CallState_Waiting;
  const factory CallState.roomJoin(
    String field0,
  ) = CallState_RoomJoin;
  const factory CallState.roomLeave(
    String field0,
  ) = CallState_RoomLeave;
  const factory CallState.callEnded(
    String field0,
    bool field1,
  ) = CallState_CallEnded;
}

class SendToDartLogger {
  const SendToDartLogger();

  static Stream<String> setStreamSink() =>
      RustLib.instance.api.crateFlutterSendToDartLoggerSetStreamSink();

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SendToDartLogger && runtimeType == other.runtimeType;
}

@freezed
sealed class SessionStatus with _$SessionStatus {
  const SessionStatus._();

  const factory SessionStatus.connecting() = SessionStatus_Connecting;
  const factory SessionStatus.connected({
    required bool relayed,
  }) = SessionStatus_Connected;
  const factory SessionStatus.inactive() = SessionStatus_Inactive;
  const factory SessionStatus.unknown() = SessionStatus_Unknown;
}

/// processed statistics for the frontend
class Statistics {
  /// a percentage of the max input volume in the window
  final double inputLevel;

  /// a percentage of the max output volume in the window
  final double outputLevel;

  /// the current call latency
  final BigInt latency;

  /// the approximate upload bandwidth used by the current call
  final BigInt uploadBandwidth;

  /// the approximate download bandwidth used by the current call
  final BigInt downloadBandwidth;

  /// the number of output samples that were lost in the interval
  final BigInt loss;

  const Statistics({
    required this.inputLevel,
    required this.outputLevel,
    required this.latency,
    required this.uploadBandwidth,
    required this.downloadBandwidth,
    required this.loss,
  });

  static Future<Statistics> default_() =>
      RustLib.instance.api.crateFlutterStatisticsDefault();

  @override
  int get hashCode =>
      inputLevel.hashCode ^
      outputLevel.hashCode ^
      latency.hashCode ^
      uploadBandwidth.hashCode ^
      downloadBandwidth.hashCode ^
      loss.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Statistics &&
          runtimeType == other.runtimeType &&
          inputLevel == other.inputLevel &&
          outputLevel == other.outputLevel &&
          latency == other.latency &&
          uploadBandwidth == other.uploadBandwidth &&
          downloadBandwidth == other.downloadBandwidth &&
          loss == other.loss;
}
