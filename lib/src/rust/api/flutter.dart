// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `SEND_TO_DART_LOGGER_STREAM_SINK`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `deref`, `do_logs`, `fmt`, `fmt`, `fmt`, `initialize`

Stream<String> createLogStream() =>
    RustLib.instance.api.crateApiFlutterCreateLogStream();

void rustSetUp() => RustLib.instance.api.crateApiFlutterRustSetUp();

(String, Uint8List) generateKeys() =>
    RustLib.instance.api.crateApiFlutterGenerateKeys();

String roomHash({required List<String> peers}) =>
    RustLib.instance.api.crateApiFlutterRoomHash(peers: peers);

bool validatePeerId({required String peerId}) =>
    RustLib.instance.api.crateApiFlutterValidatePeerId(peerId: peerId);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Capabilities>>
abstract class Capabilities implements RustOpaqueInterface {
  static Future<Capabilities> default_() =>
      RustLib.instance.api.crateApiFlutterCapabilitiesDefault();

  List<String> devices();

  List<String> encoders();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChatMessage>>
abstract class ChatMessage implements RustOpaqueInterface {
  List<(String, Uint8List)> attachments();

  String get text;

  set text(String text);

  void clearAttachments();

  bool isSender({required String identity});

  String time();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CodecConfig>>
abstract class CodecConfig implements RustOpaqueInterface {
  factory CodecConfig(
          {required bool enabled,
          required bool vbr,
          required double residualBits}) =>
      RustLib.instance.api.crateApiFlutterCodecConfigNew(
          enabled: enabled, vbr: vbr, residualBits: residualBits);

  void setEnabled({required bool enabled});

  void setResidualBits({required double residualBits});

  void setVbr({required bool vbr});

  (bool, bool, double) toValues();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Contact>>
abstract class Contact implements RustOpaqueInterface {
  bool extraOne();

  static Contact fromParts(
          {required String id,
          required String nickname,
          required String peerId}) =>
      RustLib.instance.api.crateApiFlutterContactFromParts(
          id: id, nickname: nickname, peerId: peerId);

  String id();

  bool idEq({required List<int> id});

  factory Contact({required String nickname, required String peerId}) =>
      RustLib.instance.api
          .crateApiFlutterContactNew(nickname: nickname, peerId: peerId);

  String nickname();

  String peerId();

  Contact pubClone();

  void setNickname({required String nickname});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartNotify>>
abstract class DartNotify implements RustOpaqueInterface {
  /// public notified function for dart
  Future<void> notified();

  /// notifies one waiter
  void notify();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkConfig>>
abstract class NetworkConfig implements RustOpaqueInterface {
  Future<String> getRelayAddress();

  Future<String> getRelayId();

  factory NetworkConfig(
          {required String relayAddress, required String relayId}) =>
      RustLib.instance.api.crateApiFlutterNetworkConfigNew(
          relayAddress: relayAddress, relayId: relayId);

  Future<void> setRelayAddress({required String relayAddress});

  Future<void> setRelayId({required String relayId});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RecordingConfig>>
abstract class RecordingConfig implements RustOpaqueInterface {
  int bitrate();

  String device();

  String encoder();

  int framerate();

  int? height();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ScreenshareConfig>>
abstract class ScreenshareConfig implements RustOpaqueInterface {
  Future<Capabilities> capabilities();

  static Future<ScreenshareConfig> default_() =>
      RustLib.instance.api.crateApiFlutterScreenshareConfigDefault();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<ScreenshareConfig> newInstance({required String configStr}) =>
      RustLib.instance.api
          .crateApiFlutterScreenshareConfigNew(configStr: configStr);

  Future<RecordingConfig?> recordingConfig();

  @override
  String toString();

  Future<void> updateRecordingConfig(
      {required String encoder,
      required String device,
      required int bitrate,
      required int framerate,
      int? height});
}

class SendToDartLogger {
  const SendToDartLogger();

  static Stream<String> setStreamSink() =>
      RustLib.instance.api.crateApiFlutterSendToDartLoggerSetStreamSink();

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SendToDartLogger && runtimeType == other.runtimeType;
}

/// processed statistics for the frontend
class Statistics {
  /// a percentage of the max input volume in the window
  final double inputLevel;

  /// a percentage of the max output volume in the window
  final double outputLevel;

  /// the current call latency
  final BigInt latency;

  /// the approximate upload bandwidth used by the current call
  final BigInt uploadBandwidth;

  /// the approximate download bandwidth used by the current call
  final BigInt downloadBandwidth;

  /// a value between 0 and 1 representing the percent of audio lost in a sliding window
  final double loss;

  const Statistics({
    required this.inputLevel,
    required this.outputLevel,
    required this.latency,
    required this.uploadBandwidth,
    required this.downloadBandwidth,
    required this.loss,
  });

  static Future<Statistics> default_() =>
      RustLib.instance.api.crateApiFlutterStatisticsDefault();

  @override
  int get hashCode =>
      inputLevel.hashCode ^
      outputLevel.hashCode ^
      latency.hashCode ^
      uploadBandwidth.hashCode ^
      downloadBandwidth.hashCode ^
      loss.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Statistics &&
          runtimeType == other.runtimeType &&
          inputLevel == other.inputLevel &&
          outputLevel == other.outputLevel &&
          latency == other.latency &&
          uploadBandwidth == other.uploadBandwidth &&
          downloadBandwidth == other.downloadBandwidth &&
          loss == other.loss;
}
